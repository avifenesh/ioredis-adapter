/**
 * RedisAdapter Implementation
 * ioredis-compatible client built on valkey-glide
 */

import { Batch, GlideClient, Script, TimeUnit } from '@valkey/valkey-glide';
import { EventEmitter } from 'events';
import {
  ConnectionStatus,
  IRedisAdapter,
  Multi,
  Pipeline,
  RedisKey,
  RedisOptions,
  RedisValue,
} from '../types';
import { ParameterTranslator } from '../utils/ParameterTranslator';

export class RedisAdapter extends EventEmitter implements IRedisAdapter {
  private _status: ConnectionStatus = 'disconnected';
  private client: GlideClient | null = null;
  private _options: RedisOptions;

  constructor();
  constructor(port: number, host?: string);
  constructor(options: RedisOptions);
  constructor(url: string);
  constructor(portOrOptions?: number | RedisOptions | string, host?: string) {
    super();
    
    // Parse constructor arguments (ioredis style)
    if (typeof portOrOptions === 'number') {
      this._options = { port: portOrOptions, host: host || 'localhost' };
    } else if (typeof portOrOptions === 'string') {
      this._options = this.parseRedisUrl(portOrOptions);
    } else if (typeof portOrOptions === 'object') {
      this._options = portOrOptions;
    } else {
      this._options = { port: 6379, host: 'localhost' };
    }
  }

  get status(): ConnectionStatus {
    return this._status;
  }

  get options(): RedisOptions {
    return this._options;
  }

  private parseRedisUrl(url: string): RedisOptions {
    // Simple URL parsing for redis:// URLs
    const match = url.match(/redis:\/\/(.*?):(\d+)/);
    if (match && match[1] && match[2]) {
      return { host: match[1], port: parseInt(match[2], 10) };
    }
    return { host: 'localhost', port: 6379 };
  }

  // Connection management
  async connect(): Promise<void> {
    if (this._status === 'ready' || this._status === 'connecting') {
      return;
    }

    try {
      this._status = 'connecting';
      this.emit('connect');
      
      const config = {
        addresses: [{ host: this._options.host || 'localhost', port: this._options.port || 6379 }],
        ...(this._options.password && { 
          credentials: { password: this._options.password }
        })
      };
      
      // Import GlideClient dynamically to handle potential import issues
      const { GlideClient } = await import('@valkey/valkey-glide');
      this.client = await GlideClient.createClient(config);
      
      this._status = 'ready';
      this.emit('ready');
    } catch (error) {
      this._status = 'error';
      this.emit('error', error);
      throw error;
    }
  }

  async disconnect(): Promise<void> {
    if (this._status === 'disconnected' || this._status === 'disconnecting') {
      return;
    }

    try {
      this._status = 'disconnecting';
      
      if (this.client) {
        await this.client.close();
        this.client = null;
      }
      
      this._status = 'end';
      this.emit('end');
    } catch (error) {
      this._status = 'error';
      this.emit('error', error);
      throw error;
    }
  }

  async ping(message?: string): Promise<string> {
    if (!this.client) {
      throw new Error('Redis client not connected. Call connect() first.');
    }
    const result = await this.client.ping(message ? { message } : undefined);
    return (result?.toString() || 'PONG');
  }

  /**
   * Ensure client is connected before executing commands
   */
  private async ensureConnected(): Promise<GlideClient> {
    if (!this.client) {
      await this.connect();
    }
    
    if (!this.client) {
      throw new Error('Failed to establish connection');
    }
    
    return this.client;
  }

  // String commands
  async set(key: RedisKey, value: RedisValue, ...args: any[]): Promise<string | null> {
    const client = await this.ensureConnected();
    const translated = ParameterTranslator.translateSetArgs([key, value, ...args]);
    
    const result = await client.set(translated.key, translated.value, translated.options);
    
    // If result is null, it means conditional set failed (NX/XX condition not met)
    if (result === null) {
      return null;
    }
    
    return ParameterTranslator.convertGlideString(result) || 'OK';
  }

  async get(key: RedisKey): Promise<string | null> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.get(normalizedKey);
    return ParameterTranslator.convertGlideString(result);
  }

  async mget(...keysOrArray: any[]): Promise<(string | null)[]> {
    const client = await this.ensureConnected();
    const keyStrings = ParameterTranslator.translateMGetArgs(keysOrArray);
    const result = await client.mget(keyStrings);
    return ParameterTranslator.convertGlideStringArray(result);
  }

  async mset(...argsOrHash: any[]): Promise<string> {
    const client = await this.ensureConnected();
    const keyValueMap = ParameterTranslator.translateMSetArgs(argsOrHash);
    await client.mset(keyValueMap);
    return 'OK';
  }

  async incr(key: RedisKey): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    return await client.incr(normalizedKey);
  }

  async decr(key: RedisKey): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    return await client.decr(normalizedKey);
  }

  async incrby(key: RedisKey, increment: number): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    return await client.incrBy(normalizedKey, increment);
  }

  async decrby(key: RedisKey, decrement: number): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    return await client.decrBy(normalizedKey, decrement);
  }

  async incrbyfloat(key: RedisKey, increment: number): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    return await client.incrByFloat(normalizedKey, increment);
  }

  async append(key: RedisKey, value: RedisValue): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const normalizedValue = ParameterTranslator.normalizeValue(value);
    return await client.append(normalizedKey, normalizedValue);
  }

  async strlen(key: RedisKey): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    return await client.strlen(normalizedKey);
  }

  async getrange(key: RedisKey, start: number, end: number): Promise<string> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.getrange(normalizedKey, start, end);
    return ParameterTranslator.convertGlideString(result) || '';
  }

  async setrange(key: RedisKey, offset: number, value: RedisValue): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const normalizedValue = ParameterTranslator.normalizeValue(value);
    return await client.setrange(normalizedKey, offset, normalizedValue);
  }

  async setex(key: RedisKey, seconds: number, value: RedisValue): Promise<string> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const normalizedValue = ParameterTranslator.normalizeValue(value);
    
    const result = await client.set(normalizedKey, normalizedValue, {
      expiry: { type: TimeUnit.Seconds, count: seconds }
    });
    return ParameterTranslator.convertGlideString(result) || 'OK';
  }

  async setnx(key: RedisKey, value: RedisValue): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const normalizedValue = ParameterTranslator.normalizeValue(value);
    
    const result = await client.set(normalizedKey, normalizedValue, {
      conditionalSet: 'onlyIfDoesNotExist'
    });
    return result !== null ? 1 : 0;
  }

  async psetex(key: RedisKey, milliseconds: number, value: RedisValue): Promise<string> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const normalizedValue = ParameterTranslator.normalizeValue(value);
    
    const result = await client.set(normalizedKey, normalizedValue, {
      expiry: { type: TimeUnit.Milliseconds, count: milliseconds }
    });
    return ParameterTranslator.convertGlideString(result) || 'OK';
  }

  // Hash commands - Using ParameterTranslator
  async hset(key: RedisKey, ...argsOrHash: any[]): Promise<number> {
    const client = await this.ensureConnected();
    
    // Use ParameterTranslator to handle ioredis-style arguments
    const translated = ParameterTranslator.translateHSetArgs([key, ...argsOrHash]);
    
    // Convert to valkey-glide HashDataType format
    const hashDataType = Object.entries(translated.fieldValues).map(([field, value]) => ({
      field,
      value
    }));
    
    const result = await client.hset(translated.key, hashDataType);
    return result;
  }

  async hget(key: RedisKey, field: string): Promise<string | null> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.hget(normalizedKey, field);
    return ParameterTranslator.convertGlideString(result);
  }

  async hmset(key: RedisKey, ...argsOrHash: any[]): Promise<string> {
    const client = await this.ensureConnected();
    
    // Use ParameterTranslator to handle ioredis-style arguments
    const translated = ParameterTranslator.translateHSetArgs([key, ...argsOrHash]);
    
    // Convert to valkey-glide HashDataType format
    const hashDataType = Object.entries(translated.fieldValues).map(([field, value]) => ({
      field,
      value
    }));
    
    await client.hset(translated.key, hashDataType);
    return 'OK';
  }

  async hmget(key: RedisKey, ...fieldsOrArray: any[]): Promise<(string | null)[]> {
    const client = await this.ensureConnected();
    
    // Use ParameterTranslator to handle ioredis-style arguments
    const translated = ParameterTranslator.translateHMGetArgs([key, ...fieldsOrArray]);
    
    const result = await client.hmget(translated.key, translated.fields);
    return ParameterTranslator.convertGlideStringArray(result);
  }

  async hgetall(key: RedisKey): Promise<Record<string, string>> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.hgetall(normalizedKey);
    
    // Convert valkey-glide return type to ioredis format
    const converted: Record<string, string> = {};
    
    if (!result) {
      return converted;
    }
    
    // valkey-glide returns Record<GlideString, GlideString>
    for (const [field, value] of Object.entries(result)) {
      const fieldStr = ParameterTranslator.convertGlideString(field) || '';
      const valueStr = ParameterTranslator.convertGlideString(value) || '';
      converted[fieldStr] = valueStr;
    }
    
    return converted;
  }

  async hdel(key: RedisKey, ...fields: string[]): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.hdel(normalizedKey, fields);
    return result;
  }

  async hexists(key: RedisKey, field: string): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.hexists(normalizedKey, field);
    return result ? 1 : 0;
  }

  async hkeys(key: RedisKey): Promise<string[]> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.hkeys(normalizedKey);
    return result.map((key: any) => ParameterTranslator.convertGlideString(key) || '');
  }

  async hvals(key: RedisKey): Promise<string[]> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.hvals(normalizedKey);
    return result.map((value: any) => ParameterTranslator.convertGlideString(value) || '');
  }

  async hlen(key: RedisKey): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.hlen(normalizedKey);
    return result;
  }

  async hincrby(key: RedisKey, field: string, increment: number): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.hincrBy(normalizedKey, field, increment);
    return result;
  }

  async hincrbyfloat(key: RedisKey, field: string, increment: number): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.hincrByFloat(normalizedKey, field, increment);
    return result;
  }

  async hsetnx(key: RedisKey, field: string, value: RedisValue): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const normalizedValue = ParameterTranslator.normalizeValue(value);
    const result = await client.hsetnx(normalizedKey, field, normalizedValue);
    return result ? 1 : 0;
  }

  // List commands - Using ParameterTranslator
  async lpush(key: RedisKey, ...elementsOrArray: any[]): Promise<number> {
    const client = await this.ensureConnected();
    
    // Use ParameterTranslator to handle ioredis-style arguments
    const translated = ParameterTranslator.translateListPushArgs([key, ...elementsOrArray]);
    
    const result = await client.lpush(translated.key, translated.elements);
    return result;
  }

  async rpush(key: RedisKey, ...elementsOrArray: any[]): Promise<number> {
    const client = await this.ensureConnected();
    
    // Use ParameterTranslator to handle ioredis-style arguments
    const translated = ParameterTranslator.translateListPushArgs([key, ...elementsOrArray]);
    
    const result = await client.rpush(translated.key, translated.elements);
    return result;
  }

  async lpop(key: RedisKey, count?: number): Promise<string | string[] | null> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    
    if (count !== undefined) {
      const result = await client.lpopCount(normalizedKey, count);
      return result ? ParameterTranslator.convertGlideStringArray(result).filter(item => item !== null) as string[] : null;
    } else {
      const result = await client.lpop(normalizedKey);
      return ParameterTranslator.convertGlideString(result);
    }
  }

  async rpop(key: RedisKey, count?: number): Promise<string | string[] | null> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    
    if (count !== undefined) {
      const result = await client.rpopCount(normalizedKey, count);
      return result ? ParameterTranslator.convertGlideStringArray(result).filter(item => item !== null) as string[] : null;
    } else {
      const result = await client.rpop(normalizedKey);
      return ParameterTranslator.convertGlideString(result);
    }
  }

  async lrange(key: RedisKey, start: number, stop: number): Promise<string[]> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.lrange(normalizedKey, start, stop);
    return ParameterTranslator.convertGlideStringArray(result).filter(item => item !== null) as string[];
  }

  async llen(key: RedisKey): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.llen(normalizedKey);
    return result;
  }

  async lindex(key: RedisKey, index: number): Promise<string | null> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.lindex(normalizedKey, index);
    return ParameterTranslator.convertGlideString(result);
  }

  async lset(key: RedisKey, index: number, element: RedisValue): Promise<string> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const normalizedElement = ParameterTranslator.normalizeValue(element);
    await client.lset(normalizedKey, index, normalizedElement);
    return 'OK';
  }

  async ltrim(key: RedisKey, start: number, stop: number): Promise<string> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    await client.ltrim(normalizedKey, start, stop);
    return 'OK';
  }

  async lrem(key: RedisKey, count: number, element: RedisValue): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const normalizedElement = ParameterTranslator.normalizeValue(element);
    const result = await client.lrem(normalizedKey, count, normalizedElement);
    return result;
  }

  async lpushx(key: RedisKey, ...elements: RedisValue[]): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const normalizedElements = elements.map(el => ParameterTranslator.normalizeValue(el));
    const result = await client.lpushx(normalizedKey, normalizedElements);
    return result;
  }

  async rpushx(key: RedisKey, ...elements: RedisValue[]): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const normalizedElements = elements.map(el => ParameterTranslator.normalizeValue(el));
    const result = await client.rpushx(normalizedKey, normalizedElements);
    return result;
  }

  // Set commands - Using ParameterTranslator
  async sadd(key: RedisKey, ...members: RedisValue[]): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const normalizedMembers = members.map(member => ParameterTranslator.normalizeValue(member));
    const result = await client.sadd(normalizedKey, normalizedMembers);
    return result;
  }

  async srem(key: RedisKey, ...members: RedisValue[]): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const normalizedMembers = members.map(member => ParameterTranslator.normalizeValue(member));
    const result = await client.srem(normalizedKey, normalizedMembers);
    return result;
  }

  async smembers(key: RedisKey): Promise<string[]> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.smembers(normalizedKey);
    // Convert Set to Array and ensure string format
    return Array.from(result).map((member: any) => ParameterTranslator.convertGlideString(member)).filter((member: string | null) => member !== null) as string[];
  }

  async scard(key: RedisKey): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.scard(normalizedKey);
    return result;
  }

  async sismember(key: RedisKey, member: RedisValue): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const normalizedMember = ParameterTranslator.normalizeValue(member);
    const result = await client.sismember(normalizedKey, normalizedMember);
    return result ? 1 : 0;
  }

  async spop(key: RedisKey, count?: number): Promise<string | string[] | null> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    
    if (count !== undefined) {
      const result = await client.spopCount(normalizedKey, count);
      return result ? Array.from(result).map((val: any) => ParameterTranslator.convertGlideString(val)).filter((val: string | null) => val !== null) as string[] : null;
    } else {
      const result = await client.spop(normalizedKey);
      return ParameterTranslator.convertGlideString(result);
    }
  }

  async srandmember(key: RedisKey, count?: number): Promise<string | string[] | null> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    
    if (count !== undefined) {
      const result = await client.srandmemberCount(normalizedKey, count);
      return result ? Array.from(result).map((val: any) => ParameterTranslator.convertGlideString(val)).filter((val: string | null) => val !== null) as string[] : null;
    } else {
      const result = await client.srandmember(normalizedKey);
      return ParameterTranslator.convertGlideString(result);
    }
  }
  // Key commands - Using ParameterTranslator
  async del(...keys: RedisKey[]): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKeys = ParameterTranslator.translateDelArgs(keys);
    const result = await client.del(normalizedKeys);
    return result;
  }

  async exists(...keys: RedisKey[]): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKeys = ParameterTranslator.translateExistsArgs(keys);
    const result = await client.exists(normalizedKeys);
    return result;
  }

  async expire(key: RedisKey, seconds: number): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.expire(normalizedKey, seconds);
    return result ? 1 : 0;
  }

  async ttl(key: RedisKey): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedKey = ParameterTranslator.normalizeKey(key);
    const result = await client.ttl(normalizedKey);
    return result;
  }

  async type(key: RedisKey): Promise<string> {
    const client = await this.ensureConnected();
    const result = await client.type(ParameterTranslator.normalizeKey(key));
    return result || 'none';
  }

  async keys(pattern: string = '*'): Promise<string[]> {
    const client = await this.ensureConnected();
    // Use SCAN instead of KEYS for better performance and valkey-glide compatibility
    const result = await client.scan('0', { match: pattern, count: 1000 });
    const keyStrings = result[1] || [];
    return keyStrings.map(key => ParameterTranslator.convertGlideString(key) || '').filter(Boolean);
  }

  // Watch commands for transaction support
  async watch(...keys: RedisKey[]): Promise<string> {
    // Execute WATCH command through valkey-glide
    const client = await this.ensureConnected();
    const normalizedKeys = keys.map(key => ParameterTranslator.normalizeKey(key));
    await client.customCommand(['WATCH', ...normalizedKeys]);
    
    return 'OK';
  }
  
  async unwatch(): Promise<string> {
    // Execute UNWATCH command through valkey-glide
    const client = await this.ensureConnected();
    await client.customCommand(['UNWATCH']);
    
    return 'OK';
  }

  async call(command: string, ...args: (string | number | Buffer)[]): Promise<any> {
    const client = await this.ensureConnected();
    // Convert args to strings for valkey-glide
    const stringArgs = args.map(arg => {
      if (Buffer.isBuffer(arg)) {
        return arg.toString();
      }
      return String(arg);
    });
    
    // Use customCommand to send arbitrary commands
    const result = await client.customCommand([command, ...stringArgs]);
    
    // Convert result if it's a GlideString
    if (result && typeof result === 'object' && 'toString' in result) {
      return ParameterTranslator.convertGlideString(result);
    }
    
    return result;
  }

  // Pipeline and transactions
  pipeline(): Pipeline {
    return new PipelineAdapter(this);
  }

  multi(): Multi {
    return new MultiAdapter(this);
  }

  // Pub/Sub
  async publish(channel: string, message: RedisValue): Promise<number> {
    const client = await this.ensureConnected();
    const normalizedChannel = ParameterTranslator.normalizeKey(channel);
    const normalizedMessage = ParameterTranslator.normalizeValue(message);
    
    const result = await client.publish(normalizedChannel, normalizedMessage);
    return typeof result === 'number' ? result : 0;
  }

  async subscribe(...channels: string[]): Promise<number> {
    // For now, return the number of channels subscribed to
    return channels.length;
  }

  async unsubscribe(...channels: string[]): Promise<number> {
    // For now, return the number of channels unsubscribed from
    return channels.length;
  }

  async psubscribe(...patterns: string[]): Promise<number> {
    // For now, return the number of patterns subscribed to
    return patterns.length;
  }

  async punsubscribe(...patterns: string[]): Promise<number> {
    // For now, return the number of patterns unsubscribed from
    return patterns.length;
  }

  // Script methods implementation using Valkey Glide's Script object and customCommand
  async scriptLoad(script: string): Promise<string> {
    const client = await this.ensureConnected();
    // Create a Script object which automatically handles caching
    const scriptObj = new Script(script);
    // The hash is available immediately from the Script object
    const hash = scriptObj.getHash();
    // Load the script into Redis to ensure it's cached
    await client.customCommand(['SCRIPT', 'LOAD', script]);
    return hash;
  }

  async scriptExists(...scripts: string[]): Promise<boolean[]> {
    const client = await this.ensureConnected();
    const result = await client.customCommand(['SCRIPT', 'EXISTS', ...scripts]);
    // The result should be an array of 0s and 1s
    if (Array.isArray(result)) {
      return result.map((val: any) => val === 1);
    }
    // Fallback in case of unexpected result format
    return scripts.map(() => false);
  }

  async scriptFlush(): Promise<string> {
    const client = await this.ensureConnected();
    await client.customCommand(['SCRIPT', 'FLUSH']);
    return 'OK';
  }

  async eval(script: string, numkeys: number, ...keysAndArgs: any[]): Promise<any> {
    const client = await this.ensureConnected();
    // Convert keys and arguments to appropriate format
    const keys = keysAndArgs.slice(0, numkeys).map(String);
    const args = keysAndArgs.slice(numkeys).map(String);
    // Execute the script using customCommand
    const commandArgs = [script, numkeys.toString(), ...keys, ...args];
    return await client.customCommand(['EVAL', ...commandArgs]);
  }

  async evalsha(sha1: string, numkeys: number, ...keysAndArgs: any[]): Promise<any> {
    const client = await this.ensureConnected();
    // Convert keys and arguments to appropriate format
    const keys = keysAndArgs.slice(0, numkeys).map(String);
    const args = keysAndArgs.slice(numkeys).map(String);
    // Execute the script using customCommand
    const commandArgs = [sha1, numkeys.toString(), ...keys, ...args];
    return await client.customCommand(['EVALSHA', ...commandArgs]);
  }
}

// Pipeline mock implementation
class PipelineAdapter implements Pipeline {
  protected commands: Array<{ method: string; args: any[] }> = [];
  protected redis: RedisAdapter;

  constructor(redis: RedisAdapter) {
    this.redis = redis;
  }

  // String commands
  set(key: RedisKey, value: RedisValue, ...args: any[]): Pipeline {
    this.commands.push({ method: 'set', args: [key, value, ...args] });
    return this;
  }

  get(key: RedisKey): Pipeline {
    this.commands.push({ method: 'get', args: [key] });
    return this;
  }

  mget(...keys: any[]): Pipeline {
    this.commands.push({ method: 'mget', args: keys });
    return this;
  }

  mset(...args: any[]): Pipeline {
    this.commands.push({ method: 'mset', args });
    return this;
  }

  incr(key: RedisKey): Pipeline {
    this.commands.push({ method: 'incr', args: [key] });
    return this;
  }

  decr(key: RedisKey): Pipeline {
    this.commands.push({ method: 'decr', args: [key] });
    return this;
  }

  incrby(key: RedisKey, increment: number): Pipeline {
    this.commands.push({ method: 'incrby', args: [key, increment] });
    return this;
  }

  decrby(key: RedisKey, decrement: number): Pipeline {
    this.commands.push({ method: 'decrby', args: [key, decrement] });
    return this;
  }

  incrbyfloat(key: RedisKey, increment: number): Pipeline {
    this.commands.push({ method: 'incrbyfloat', args: [key, increment] });
    return this;
  }

  append(key: RedisKey, value: RedisValue): Pipeline {
    this.commands.push({ method: 'append', args: [key, value] });
    return this;
  }

  strlen(key: RedisKey): Pipeline {
    this.commands.push({ method: 'strlen', args: [key] });
    return this;
  }

  getrange(key: RedisKey, start: number, end: number): Pipeline {
    this.commands.push({ method: 'getrange', args: [key, start, end] });
    return this;
  }

  setrange(key: RedisKey, offset: number, value: RedisValue): Pipeline {
    this.commands.push({ method: 'setrange', args: [key, offset, value] });
    return this;
  }

  setex(key: RedisKey, seconds: number, value: RedisValue): Pipeline {
    this.commands.push({ method: 'setex', args: [key, seconds, value] });
    return this;
  }

  setnx(key: RedisKey, value: RedisValue): Pipeline {
    this.commands.push({ method: 'setnx', args: [key, value] });
    return this;
  }

  psetex(key: RedisKey, milliseconds: number, value: RedisValue): Pipeline {
    this.commands.push({ method: 'psetex', args: [key, milliseconds, value] });
    return this;
  }

  // Hash commands
  hset(key: RedisKey, ...args: any[]): Pipeline {
    this.commands.push({ method: 'hset', args: [key, ...args] });
    return this;
  }

  hget(key: RedisKey, field: string): Pipeline {
    this.commands.push({ method: 'hget', args: [key, field] });
    return this;
  }

  hmset(key: RedisKey, ...args: any[]): Pipeline {
    this.commands.push({ method: 'hmset', args: [key, ...args] });
    return this;
  }

  hmget(key: RedisKey, ...fields: any[]): Pipeline {
    this.commands.push({ method: 'hmget', args: [key, ...fields] });
    return this;
  }

  hgetall(key: RedisKey): Pipeline {
    this.commands.push({ method: 'hgetall', args: [key] });
    return this;
  }

  hdel(key: RedisKey, ...fields: string[]): Pipeline {
    this.commands.push({ method: 'hdel', args: [key, ...fields] });
    return this;
  }

  hexists(key: RedisKey, field: string): Pipeline {
    this.commands.push({ method: 'hexists', args: [key, field] });
    return this;
  }

  hkeys(key: RedisKey): Pipeline {
    this.commands.push({ method: 'hkeys', args: [key] });
    return this;
  }

  hvals(key: RedisKey): Pipeline {
    this.commands.push({ method: 'hvals', args: [key] });
    return this;
  }

  hlen(key: RedisKey): Pipeline {
    this.commands.push({ method: 'hlen', args: [key] });
    return this;
  }

  hincrby(key: RedisKey, field: string, increment: number): Pipeline {
    this.commands.push({ method: 'hincrby', args: [key, field, increment] });
    return this;
  }

  hincrbyfloat(key: RedisKey, field: string, increment: number): Pipeline {
    this.commands.push({ method: 'hincrbyfloat', args: [key, field, increment] });
    return this;
  }

  hsetnx(key: RedisKey, field: string, value: RedisValue): Pipeline {
    this.commands.push({ method: 'hsetnx', args: [key, field, value] });
    return this;
  }

  // List commands
  lpush(key: RedisKey, ...elements: any[]): Pipeline {
    this.commands.push({ method: 'lpush', args: [key, ...elements] });
    return this;
  }

  rpush(key: RedisKey, ...elements: any[]): Pipeline {
    this.commands.push({ method: 'rpush', args: [key, ...elements] });
    return this;
  }

  lpop(key: RedisKey, count?: number): Pipeline {
    this.commands.push({ method: 'lpop', args: count !== undefined ? [key, count] : [key] });
    return this;
  }

  rpop(key: RedisKey, count?: number): Pipeline {
    this.commands.push({ method: 'rpop', args: count !== undefined ? [key, count] : [key] });
    return this;
  }

  lrange(key: RedisKey, start: number, stop: number): Pipeline {
    this.commands.push({ method: 'lrange', args: [key, start, stop] });
    return this;
  }

  llen(key: RedisKey): Pipeline {
    this.commands.push({ method: 'llen', args: [key] });
    return this;
  }

  lindex(key: RedisKey, index: number): Pipeline {
    this.commands.push({ method: 'lindex', args: [key, index] });
    return this;
  }

  lset(key: RedisKey, index: number, element: RedisValue): Pipeline {
    this.commands.push({ method: 'lset', args: [key, index, element] });
    return this;
  }

  ltrim(key: RedisKey, start: number, stop: number): Pipeline {
    this.commands.push({ method: 'ltrim', args: [key, start, stop] });
    return this;
  }

  lrem(key: RedisKey, count: number, element: RedisValue): Pipeline {
    this.commands.push({ method: 'lrem', args: [key, count, element] });
    return this;
  }

  lpushx(key: RedisKey, ...elements: RedisValue[]): Pipeline {
    this.commands.push({ method: 'lpushx', args: [key, ...elements] });
    return this;
  }

  rpushx(key: RedisKey, ...elements: RedisValue[]): Pipeline {
    this.commands.push({ method: 'rpushx', args: [key, ...elements] });
    return this;
  }

  // Key commands
  del(...keys: RedisKey[]): Pipeline {
    this.commands.push({ method: 'del', args: keys });
    return this;
  }

  exists(...keys: RedisKey[]): Pipeline {
    this.commands.push({ method: 'exists', args: keys });
    return this;
  }

  expire(key: RedisKey, seconds: number): Pipeline {
    this.commands.push({ method: 'expire', args: [key, seconds] });
    return this;
  }

  ttl(key: RedisKey): Pipeline {
    this.commands.push({ method: 'ttl', args: [key] });
    return this;
  }

  type(key: RedisKey): Pipeline {
    this.commands.push({ method: 'type', args: [key] });
    return this;
  }

  // Pub/Sub commands
  publish(channel: string, message: RedisValue): Pipeline {
    this.commands.push({ method: 'publish', args: [channel, message] });
    return this;
  }

  async exec(): Promise<Array<[Error | null, any]>> {
    if (this.commands.length === 0) {
      return [];
    }

    const client = await (this.redis as any).ensureConnected();
    const batch = new Batch(false); // Non-atomic pipeline

    // Add all commands to the batch
    for (const cmd of this.commands) {
      try {
        this.addCommandToBatch(batch, cmd.method, cmd.args);
      } catch (error) {
        // If there's an error adding a command, return it in the results
        continue;
      }
    }

    try {
      // Execute the batch
      const results = await client.exec(batch, false); // raiseOnError = false
      
      // Convert results to ioredis format: [Error | null, result]
      const formattedResults: Array<[Error | null, any]> = [];
      
      if (results) {
        for (let i = 0; i < results.length; i++) {
          const result = results[i];
          if (result instanceof Error) {
            formattedResults.push([result, null]);
          } else {
            formattedResults.push([null, result]);
          }
        }
      }
      
      return formattedResults;
    } catch (error) {
      // If the entire batch fails, return error for all commands
      return this.commands.map(() => [error as Error, null]);
    } finally {
      // Clear commands after execution
      this.commands = [];
    }
  }

  protected addCommandToBatch(batch: Batch, method: string, args: any[]): void {
    // Map pipeline commands to batch methods
    switch (method) {
      case 'set':
        if (args.length >= 2) {
          const translated = ParameterTranslator.translateSetArgs(args);
          batch.set(translated.key, translated.value, translated.options);
        }
        break;
      case 'get':
        if (args.length >= 1) {
          batch.get(ParameterTranslator.normalizeKey(args[0]));
        }
        break;
      case 'mget':
        const mgetKeys = ParameterTranslator.translateMGetArgs(args);
        batch.mget(mgetKeys);
        break;
      case 'mset':
        const msetData = ParameterTranslator.translateMSetArgs(args);
        batch.mset(msetData);
        break;
      case 'incr':
        batch.incr(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'decr':
        batch.decr(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'incrby':
        batch.incrBy(ParameterTranslator.normalizeKey(args[0]), args[1]);
        break;
      case 'decrby':
        batch.decrBy(ParameterTranslator.normalizeKey(args[0]), args[1]);
        break;
      case 'incrbyfloat':
        batch.incrByFloat(ParameterTranslator.normalizeKey(args[0]), args[1]);
        break;
      case 'append':
        batch.append(ParameterTranslator.normalizeKey(args[0]), ParameterTranslator.normalizeValue(args[1]));
        break;
      case 'strlen':
        batch.strlen(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'getrange':
        batch.getrange(ParameterTranslator.normalizeKey(args[0]), args[1], args[2]);
        break;
      case 'setrange':
        batch.setrange(ParameterTranslator.normalizeKey(args[0]), args[1], ParameterTranslator.normalizeValue(args[2]));
        break;
      case 'setex':
        batch.set(ParameterTranslator.normalizeKey(args[0]), ParameterTranslator.normalizeValue(args[2]), {
          expiry: { type: TimeUnit.Seconds, count: args[1] }
        });
        break;
      case 'setnx':
        batch.set(ParameterTranslator.normalizeKey(args[0]), ParameterTranslator.normalizeValue(args[1]), {
          conditionalSet: 'onlyIfDoesNotExist'
        });
        break;
      case 'psetex':
        batch.set(ParameterTranslator.normalizeKey(args[0]), ParameterTranslator.normalizeValue(args[2]), {
          expiry: { type: TimeUnit.Milliseconds, count: args[1] }
        });
        break;
      // Hash commands
      case 'hset':
        const hsetTranslated = ParameterTranslator.translateHSetArgs(args);
        const hashDataType = Object.entries(hsetTranslated.fieldValues).map(([field, value]) => ({
          field,
          value
        }));
        batch.hset(hsetTranslated.key, hashDataType);
        break;
      case 'hget':
        batch.hget(ParameterTranslator.normalizeKey(args[0]), args[1]);
        break;
      case 'hmset':
        const hmsetTranslated = ParameterTranslator.translateHSetArgs(args);
        const hmsetHashDataType = Object.entries(hmsetTranslated.fieldValues).map(([field, value]) => ({
          field,
          value
        }));
        batch.hset(hmsetTranslated.key, hmsetHashDataType);
        break;
      case 'hmget':
        const hmgetTranslated = ParameterTranslator.translateHMGetArgs(args);
        batch.hmget(hmgetTranslated.key, hmgetTranslated.fields);
        break;
      case 'hgetall':
        batch.hgetall(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'hdel':
        batch.hdel(ParameterTranslator.normalizeKey(args[0]), args.slice(1));
        break;
      case 'hexists':
        batch.hexists(ParameterTranslator.normalizeKey(args[0]), args[1]);
        break;
      case 'hkeys':
        batch.hkeys(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'hvals':
        batch.hvals(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'hlen':
        batch.hlen(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'hincrby':
        batch.hincrBy(ParameterTranslator.normalizeKey(args[0]), args[1], args[2]);
        break;
      case 'hincrbyfloat':
        batch.hincrByFloat(ParameterTranslator.normalizeKey(args[0]), args[1], args[2]);
        break;
      case 'hsetnx':
        batch.hsetnx(ParameterTranslator.normalizeKey(args[0]), args[1], ParameterTranslator.normalizeValue(args[2]));
        break;
      // List commands
      case 'lpush':
        const lpushTranslated = ParameterTranslator.translateListPushArgs(args);
        batch.lpush(lpushTranslated.key, lpushTranslated.elements);
        break;
      case 'rpush':
        const rpushTranslated = ParameterTranslator.translateListPushArgs(args);
        batch.rpush(rpushTranslated.key, rpushTranslated.elements);
        break;
      case 'lpop':
        if (args.length > 1) {
          batch.lpopCount(ParameterTranslator.normalizeKey(args[0]), args[1]);
        } else {
          batch.lpop(ParameterTranslator.normalizeKey(args[0]));
        }
        break;
      case 'rpop':
        if (args.length > 1) {
          batch.rpopCount(ParameterTranslator.normalizeKey(args[0]), args[1]);
        } else {
          batch.rpop(ParameterTranslator.normalizeKey(args[0]));
        }
        break;
      case 'lrange':
        batch.lrange(ParameterTranslator.normalizeKey(args[0]), args[1], args[2]);
        break;
      case 'llen':
        batch.llen(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'lindex':
        batch.lindex(ParameterTranslator.normalizeKey(args[0]), args[1]);
        break;
      case 'lset':
        batch.lset(ParameterTranslator.normalizeKey(args[0]), args[1], ParameterTranslator.normalizeValue(args[2]));
        break;
      case 'ltrim':
        batch.ltrim(ParameterTranslator.normalizeKey(args[0]), args[1], args[2]);
        break;
      case 'lrem':
        batch.lrem(ParameterTranslator.normalizeKey(args[0]), args[1], ParameterTranslator.normalizeValue(args[2]));
        break;
      case 'lpushx':
        const lpushxElements = args.slice(1).map(el => ParameterTranslator.normalizeValue(el));
        batch.lpushx(ParameterTranslator.normalizeKey(args[0]), lpushxElements);
        break;
      case 'rpushx':
        const rpushxElements = args.slice(1).map(el => ParameterTranslator.normalizeValue(el));
        batch.rpushx(ParameterTranslator.normalizeKey(args[0]), rpushxElements);
        break;
      // Key commands
      case 'del':
        const delKeys = ParameterTranslator.translateDelArgs(args);
        batch.del(delKeys);
        break;
      case 'exists':
        const existsKeys = ParameterTranslator.translateExistsArgs(args);
        batch.exists(existsKeys);
        break;
      case 'expire':
        batch.expire(ParameterTranslator.normalizeKey(args[0]), args[1]);
        break;
      case 'ttl':
        batch.ttl(ParameterTranslator.normalizeKey(args[0]));
        break;
      // Pub/Sub commands
      case 'publish':
        batch.publish(ParameterTranslator.normalizeKey(args[0]), ParameterTranslator.normalizeValue(args[1]));
        break;
      default:
        throw new Error(`Unsupported pipeline command: ${method}`);
    }
  }

  discard(): void {
    this.commands = [];
  }
}

// Multi (transaction) mock implementation
class MultiAdapter implements Multi {
  protected commands: Array<{ method: string; args: any[] }> = [];
  protected redis: RedisAdapter;
  private watchedKeys: Set<string> = new Set();

  constructor(redis: RedisAdapter) {
    this.redis = redis;
  }

  // Basic pipeline methods - just store commands
  set(key: RedisKey, value: RedisValue, ...args: any[]): Multi {
    this.commands.push({ method: 'set', args: [key, value, ...args] });
    return this;
  }

  get(key: RedisKey): Multi {
    this.commands.push({ method: 'get', args: [key] });
    return this;
  }

  mget(...keys: any[]): Multi {
    this.commands.push({ method: 'mget', args: keys });
    return this;
  }

  mset(...args: any[]): Multi {
    this.commands.push({ method: 'mset', args });
    return this;
  }

  incr(key: RedisKey): Multi { this.commands.push({ method: 'incr', args: [key] }); return this; }
  decr(key: RedisKey): Multi { this.commands.push({ method: 'decr', args: [key] }); return this; }
  incrby(key: RedisKey, increment: number): Multi { this.commands.push({ method: 'incrby', args: [key, increment] }); return this; }
  decrby(key: RedisKey, decrement: number): Multi { this.commands.push({ method: 'decrby', args: [key, decrement] }); return this; }
  incrbyfloat(key: RedisKey, increment: number): Multi { this.commands.push({ method: 'incrbyfloat', args: [key, increment] }); return this; }
  append(key: RedisKey, value: RedisValue): Multi { this.commands.push({ method: 'append', args: [key, value] }); return this; }
  strlen(key: RedisKey): Multi { this.commands.push({ method: 'strlen', args: [key] }); return this; }
  getrange(key: RedisKey, start: number, end: number): Multi { this.commands.push({ method: 'getrange', args: [key, start, end] }); return this; }
  setrange(key: RedisKey, offset: number, value: RedisValue): Multi { this.commands.push({ method: 'setrange', args: [key, offset, value] }); return this; }
  setex(key: RedisKey, seconds: number, value: RedisValue): Multi { this.commands.push({ method: 'setex', args: [key, seconds, value] }); return this; }
  setnx(key: RedisKey, value: RedisValue): Multi { this.commands.push({ method: 'setnx', args: [key, value] }); return this; }
  psetex(key: RedisKey, milliseconds: number, value: RedisValue): Multi { this.commands.push({ method: 'psetex', args: [key, milliseconds, value] }); return this; }

  // Hash commands
  hset(key: RedisKey, ...args: any[]): Multi { this.commands.push({ method: 'hset', args: [key, ...args] }); return this; }
  hget(key: RedisKey, field: string): Multi { this.commands.push({ method: 'hget', args: [key, field] }); return this; }
  hmset(key: RedisKey, ...args: any[]): Multi { this.commands.push({ method: 'hmset', args: [key, ...args] }); return this; }
  hmget(key: RedisKey, ...fields: any[]): Multi { this.commands.push({ method: 'hmget', args: [key, ...fields] }); return this; }
  hgetall(key: RedisKey): Multi { this.commands.push({ method: 'hgetall', args: [key] }); return this; }
  hdel(key: RedisKey, ...fields: string[]): Multi { this.commands.push({ method: 'hdel', args: [key, ...fields] }); return this; }
  hexists(key: RedisKey, field: string): Multi { this.commands.push({ method: 'hexists', args: [key, field] }); return this; }
  hkeys(key: RedisKey): Multi { this.commands.push({ method: 'hkeys', args: [key] }); return this; }
  hvals(key: RedisKey): Multi { this.commands.push({ method: 'hvals', args: [key] }); return this; }
  hlen(key: RedisKey): Multi { this.commands.push({ method: 'hlen', args: [key] }); return this; }
  hincrby(key: RedisKey, field: string, increment: number): Multi { this.commands.push({ method: 'hincrby', args: [key, field, increment] }); return this; }
  hincrbyfloat(key: RedisKey, field: string, increment: number): Multi { this.commands.push({ method: 'hincrbyfloat', args: [key, field, increment] }); return this; }
  hsetnx(key: RedisKey, field: string, value: RedisValue): Multi { this.commands.push({ method: 'hsetnx', args: [key, field, value] }); return this; }

  // List commands
  lpush(key: RedisKey, ...elements: any[]): Multi { this.commands.push({ method: 'lpush', args: [key, ...elements] }); return this; }
  rpush(key: RedisKey, ...elements: any[]): Multi { this.commands.push({ method: 'rpush', args: [key, ...elements] }); return this; }
  lpop(key: RedisKey, count?: number): Multi { this.commands.push({ method: 'lpop', args: count !== undefined ? [key, count] : [key] }); return this; }
  rpop(key: RedisKey, count?: number): Multi { this.commands.push({ method: 'rpop', args: count !== undefined ? [key, count] : [key] }); return this; }
  lrange(key: RedisKey, start: number, stop: number): Multi { this.commands.push({ method: 'lrange', args: [key, start, stop] }); return this; }
  llen(key: RedisKey): Multi { this.commands.push({ method: 'llen', args: [key] }); return this; }
  lindex(key: RedisKey, index: number): Multi { this.commands.push({ method: 'lindex', args: [key, index] }); return this; }
  lset(key: RedisKey, index: number, element: RedisValue): Multi { this.commands.push({ method: 'lset', args: [key, index, element] }); return this; }
  ltrim(key: RedisKey, start: number, stop: number): Multi { this.commands.push({ method: 'ltrim', args: [key, start, stop] }); return this; }
  lrem(key: RedisKey, count: number, element: RedisValue): Multi { this.commands.push({ method: 'lrem', args: [key, count, element] }); return this; }
  lpushx(key: RedisKey, ...elements: RedisValue[]): Multi { this.commands.push({ method: 'lpushx', args: [key, ...elements] }); return this; }
  rpushx(key: RedisKey, ...elements: RedisValue[]): Multi { this.commands.push({ method: 'rpushx', args: [key, ...elements] }); return this; }

  // Key commands
  del(...keys: RedisKey[]): Multi { this.commands.push({ method: 'del', args: keys }); return this; }
  exists(...keys: RedisKey[]): Multi { this.commands.push({ method: 'exists', args: keys }); return this; }
  expire(key: RedisKey, seconds: number): Multi { this.commands.push({ method: 'expire', args: [key, seconds] }); return this; }
  ttl(key: RedisKey): Multi { this.commands.push({ method: 'ttl', args: [key] }); return this; }
  type(key: RedisKey): Multi { this.commands.push({ method: 'type', args: [key] }); return this; }

  discard(): void {
    this.commands = [];
  }

  async watch(...keys: RedisKey[]): Promise<string> {
    // Track keys locally
    keys.forEach(key => this.watchedKeys.add(ParameterTranslator.normalizeKey(key)));
    
    // Execute WATCH command through valkey-glide
    const client = await this.redis.ensureConnected();
    const normalizedKeys = keys.map(key => ParameterTranslator.normalizeKey(key));
    await client.customCommand(['WATCH', ...normalizedKeys]);
    
    return 'OK';
  }

  async unwatch(): Promise<string> {
    // Clear local tracking
    this.watchedKeys.clear();
    
    // Execute UNWATCH command through valkey-glide
    const client = await this.redis.ensureConnected();
    await client.customCommand(['UNWATCH']);
    
    return 'OK';
  }

  async exec(): Promise<Array<[Error | null, any]> | null> {
    if (this.commands.length === 0) {
      return [];
    }

    try {
      const client = await this.redis.ensureConnected();
      const batch = new Batch(true); // Atomic batch for transactions

      // Add all commands to the batch
      for (const cmd of this.commands) {
        try {
          this.addCommandToBatch(batch, cmd.method, cmd.args);
        } catch (error) {
          // If there's an error adding a command, continue with the rest
          continue;
        }
      }

      // Execute the atomic batch
      const results = await client.exec(batch, false); // raiseOnError = false

      // Format results to match ioredis format: [Error | null, result]
      const formattedResults: Array<[Error | null, any]> = [];

      if (results) {
        for (let i = 0; i < results.length; i++) {
          const result = results[i];
          if (result instanceof Error) {
            formattedResults.push([result, null]);
          } else {
            formattedResults.push([null, result]);
          }
        }
      }

      return formattedResults;
    } catch (error) {
      // Handle transaction failure (e.g., due to WATCH violations)
      // ioredis returns null for failed transactions
      return null;
    } finally {
      // Clear commands after execution
      this.commands = [];
    }
  }
}

// Export the classes
export { MultiAdapter, PipelineAdapter };

      // Execute the atomic batch
      const results = await client.exec(batch, false); // raiseOnError = false

      // Format results to match ioredis format: [Error | null, result]
      const formattedResults: Array<[Error | null, any]> = [];

      if (results) {
        for (let i = 0; i < results.length; i++) {
          const result = results[i];
          if (result instanceof Error) {
            formattedResults.push([result, null]);
          } else {
            formattedResults.push([null, result]);
          }
        }
      }

      return formattedResults;
    } catch (error) {
      // Handle transaction failure (e.g., due to WATCH violations)
      // ioredis returns null for failed transactions
      return null;
    } finally {
      // Clear commands after execution
      this.commands = [];
    }
  }

  protected addCommandToBatch(batch: Batch, method: string, args: any[]): void {
    // This method is similar to the one in PipelineAdapter but used for transactions
    // We can reuse the same logic since both use Batch
    // Map transaction commands to batch methods
    switch (method) {
      case 'set':
        if (args.length >= 2) {
          const translated = ParameterTranslator.translateSetArgs(args);
          batch.set(translated.key, translated.value, translated.options);
        }
        break;
      case 'get':
        if (args.length >= 1) {
          batch.get(ParameterTranslator.normalizeKey(args[0]));
        }
        break;
      case 'mget':
        const mgetKeys = ParameterTranslator.translateMGetArgs(args);
        batch.mget(mgetKeys);
        break;
      case 'mset':
        const msetData = ParameterTranslator.translateMSetArgs(args);
        batch.mset(msetData);
        break;
      case 'incr':
        batch.incr(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'decr':
        batch.decr(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'incrby':
        batch.incrBy(ParameterTranslator.normalizeKey(args[0]), args[1]);
        break;
      case 'decrby':
        batch.decrBy(ParameterTranslator.normalizeKey(args[0]), args[1]);
        break;
      case 'incrbyfloat':
        batch.incrByFloat(ParameterTranslator.normalizeKey(args[0]), args[1]);
        break;
      case 'append':
        batch.append(ParameterTranslator.normalizeKey(args[0]), ParameterTranslator.normalizeValue(args[1]));
        break;
      case 'strlen':
        batch.strlen(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'getrange':
        batch.getrange(ParameterTranslator.normalizeKey(args[0]), args[1], args[2]);
        break;
      case 'setrange':
        batch.setrange(ParameterTranslator.normalizeKey(args[0]), args[1], ParameterTranslator.normalizeValue(args[2]));
        break;
      case 'setex':
        batch.set(ParameterTranslator.normalizeKey(args[0]), ParameterTranslator.normalizeValue(args[2]), {
          expiry: { type: TimeUnit.Seconds, count: args[1] }
        });
        break;
      case 'setnx':
        batch.set(ParameterTranslator.normalizeKey(args[0]), ParameterTranslator.normalizeValue(args[1]), {
          conditionalSet: 'onlyIfDoesNotExist'
        });
        break;
      case 'psetex':
        batch.set(ParameterTranslator.normalizeKey(args[0]), ParameterTranslator.normalizeValue(args[2]), {
          expiry: { type: TimeUnit.Milliseconds, count: args[1] }
        });
        break;
      // Hash commands
      case 'hset':
        const hsetTranslated = ParameterTranslator.translateHSetArgs(args);
        const hashDataType = Object.entries(hsetTranslated.fieldValues).map(([field, value]) => ({
          field,
          value
        }));
        batch.hset(hsetTranslated.key, hashDataType);
        break;
      case 'hget':
        batch.hget(ParameterTranslator.normalizeKey(args[0]), args[1]);
        break;
      case 'hmset':
        const hmsetTranslated = ParameterTranslator.translateHSetArgs(args);
        const hmsetHashDataType = Object.entries(hmsetTranslated.fieldValues).map(([field, value]) => ({
          field,
          value
        }));
        batch.hset(hmsetTranslated.key, hmsetHashDataType);
        break;
      case 'hmget':
        const hmgetTranslated = ParameterTranslator.translateHMGetArgs(args);
        batch.hmget(hmgetTranslated.key, hmgetTranslated.fields);
        break;
      case 'hgetall':
        batch.hgetall(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'hdel':
        batch.hdel(ParameterTranslator.normalizeKey(args[0]), args.slice(1));
        break;
      case 'hexists':
        batch.hexists(ParameterTranslator.normalizeKey(args[0]), args[1]);
        break;
      case 'hkeys':
        batch.hkeys(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'hvals':
        batch.hvals(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'hlen':
        batch.hlen(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'hincrby':
        batch.hincrBy(ParameterTranslator.normalizeKey(args[0]), args[1], args[2]);
        break;
      case 'hincrbyfloat':
        batch.hincrByFloat(ParameterTranslator.normalizeKey(args[0]), args[1], args[2]);
        break;
      case 'hsetnx':
        batch.hsetnx(ParameterTranslator.normalizeKey(args[0]), args[1], ParameterTranslator.normalizeValue(args[2]));
        break;
      // List commands
      case 'lpush':
        const lpushTranslated = ParameterTranslator.translateListPushArgs(args);
        batch.lpush(lpushTranslated.key, lpushTranslated.elements);
        break;
      case 'rpush':
        const rpushTranslated = ParameterTranslator.translateListPushArgs(args);
        batch.rpush(rpushTranslated.key, rpushTranslated.elements);
        break;
      case 'lpop':
        if (args.length > 1) {
          batch.lpopCount(ParameterTranslator.normalizeKey(args[0]), args[1]);
        } else {
          batch.lpop(ParameterTranslator.normalizeKey(args[0]));
        }
        break;
      case 'rpop':
        if (args.length > 1) {
          batch.rpopCount(ParameterTranslator.normalizeKey(args[0]), args[1]);
        } else {
          batch.rpop(ParameterTranslator.normalizeKey(args[0]));
        }
        break;
      case 'lrange':
        batch.lrange(ParameterTranslator.normalizeKey(args[0]), args[1], args[2]);
        break;
      case 'llen':
        batch.llen(ParameterTranslator.normalizeKey(args[0]));
        break;
      case 'lindex':
        batch.lindex(ParameterTranslator.normalizeKey(args[0]), args[1]);
        break;
      case 'lset':
        batch.lset(ParameterTranslator.normalizeKey(args[0]), args[1], ParameterTranslator.normalizeValue(args[2]));
        break;
      case 'ltrim':
        batch.ltrim(ParameterTranslator.normalizeKey(args[0]), args[1], args[2]);
        break;
      case 'lrem':
        batch.lrem(ParameterTranslator.normalizeKey(args[0]), args[1], ParameterTranslator.normalizeValue(args[2]));
        break;
      case 'lpushx':
        const lpushxElements = args.slice(1).map(el => ParameterTranslator.normalizeValue(el));
        batch.lpushx(ParameterTranslator.normalizeKey(args[0]), lpushxElements);
        break;
      case 'rpushx':
        const rpushxElements = args.slice(1).map(el => ParameterTranslator.normalizeValue(el));
        batch.rpushx(ParameterTranslator.normalizeKey(args[0]), rpushxElements);
        break;
      // Key commands
      case 'del':
        const delKeys = ParameterTranslator.translateDelArgs(args);
        batch.del(delKeys);
        break;
      case 'exists':
        const existsKeys = ParameterTranslator.translateExistsArgs(args);
        batch.exists(existsKeys);
        break;
      case 'expire':
        batch.expire(ParameterTranslator.normalizeKey(args[0]), args[1]);
        break;
      case 'ttl':
        batch.ttl(ParameterTranslator.normalizeKey(args[0]));
        break;
      // Pub/Sub commands
      case 'publish':
        batch.publish(ParameterTranslator.normalizeKey(args[0]), ParameterTranslator.normalizeValue(args[1]));
        break;
      default:
        throw new Error(`Unsupported transaction command: ${method}`);
    }
  }
}

// Export the classes
export { MultiAdapter, PipelineAdapter };
